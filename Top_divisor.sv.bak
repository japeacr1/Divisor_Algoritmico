`timescale 1ns / 1ps

module Top_divisor();
    parameter tamanyo = 32;
    logic CLK;
    logic RSTa;

    // Instanciación de la interfaz
    Interface_if #(tamanyo) test_if(.reloj(CLK), .reset(RSTa));

    // Instanciación del diseño (DUT)
    Divisor_Algoritmico #(tamanyo) Duv (.bus(test_if));

    // Instanciación del programa de estímulos
    estimulos #(tamanyo) estim1(.testar(test_if),.monitorizar(test_if));

    // Generación del reloj (CLK)
    always begin
        CLK = 1'b0; #5;
        CLK = 1'b1; #5;
    end 

    // Reseteo
    initial begin
        RSTa = 1'b1;
        #10 RSTa = 1'b0;
        #10 RSTa = 1'b1;
    end

    // Volcado de valores para el visualizador
    initial begin
        $dumpfile("divisor.vcd");
        $dumpvars(1, Top_divisor.Duv.divisor_duv);
    end
endmodule

// Definición de la interfaz/////////////////////////////////////////////////////////////////////////////////////////
interface Interface_if #(parameter tamanyo = 32) (input bit reloj, input bit reset);
    logic Start;
    logic Done;
    logic signed [tamanyo-1:0] Num;
    logic signed[tamanyo-1:0] Den;
    logic signed[tamanyo-1:0] Coc;
    logic signed[tamanyo-1:0] Res;

    // Clocking block para monitoreo 
    clocking md @(posedge reloj);
        input #1ns Num;
        input #1ns Den;
        input #1ns Coc;
        input #1ns Res;
        input #1ns Start;
        input #1ns Done;
    endclocking: md;

    // Clocking block para generación de estímulos 
    clocking sd @(posedge reloj);
        input  #2ns Coc;
        input  #2ns Res;
        input  #2ns Done;
        output #2ns Num;
        output #2ns Den;
        output #2ns Start;
    endclocking: sd;

    modport monitor (clocking md);
    modport test (clocking sd);
    modport duv (
        input     reloj,
        input     reset,
        input     Start,
        input     Num,
        input     Den,
        output    Done,
        output    Coc,
        output    Res
    );
endinterface

// Paquete de verificación//////////////////////////////////////////////////////////////////////////////////////////
package utilidades_verificacion;

    parameter tamanyo = 32;
    
    class RCSG;

        randc logic signed [tamanyo-1:0] num_rand;
        randc logic signed [tamanyo-1:0] den_rand;

//        constraint den_valido { den_rand != 0; }
    	constraint num_constraint {
        	num_rand dist {
            	[-100 : 100] := 5,                                 // 20% de probabilidad para el rango [-100:100]
            	[-1000 : -100] := 2, [100 : 1000] := 2,            // 20% combinado para [-1,000:-100] & [100:1,000]
            	[-10000 : -1000] := 1, [1000 : 10000] := 1,        // 20% combinado para [-10,000:-1,000] & [1,000:10,000]
            	[-100000 : -10000] := 1, [10000 : 100000] := 1,    // 20% combinado para [-100,000:-10,000] & [10,000:100,000]
            	[-1000000 : -100000] := 1, [100000 : 1000000] := 1 // 20% combinado para [-1,000,000:-100,000] & [100,000:1,000,000]
        	};
    	}

    	constraint den_constraint {
        	den_rand dist {
            	[-100 : 100] := 2,
            	[-1000 : -100] := 1, [100 : 1000] := 1,
            	[-10000 : -1000] := 1, [1000 : 10000] := 1,
            	[-100000 : -10000] := 1, [10000 : 100000] := 1,
            	[-1000000 : -100000] := 1, [100000 : 1000000] := 1
        	};
        	den_rand != 0; 
    	}
 	
    endclass

    class Scoreboard;
 	logic signed[tamanyo-1:0] cola_target_coc [$];
	logic signed[tamanyo-1:0] cola_target_res [$];
	logic signed[tamanyo-1:0] pretarget_coc, pretarget_res;
        logic signed[tamanyo-1:0] target_coc, target_res;
    	logic signed[tamanyo-1:0] observado_Coc, observado_Res;

        virtual Interface_if.monitor mports;

	

        function new(virtual Interface_if.monitor mpuertos);
            this.mports = mpuertos;
	   
        endfunction


	task monitor_input;    
	    logic start_control = 1;      // Variable para evitar duplicados
	    while (1) begin
	        @(mports.md);
	        if (mports.md.Start) 
		  if (start_control) begin // Solo guardar si start_control es 1
	            pretarget_coc = mports.md.Num / mports.md.Den;
	            pretarget_res = mports.md.Num % mports.md.Den;
	            cola_target_coc.push_front(pretarget_coc);
	            cola_target_res.push_front(pretarget_res);
	            $display("|Guardamos ideal en la cola -----> Cociente: %11d, Residuo: %11d |", pretarget_coc, pretarget_res);
		    start_control = 0;     // Cambia el estado para evitar duplicados
	            end 
		else begin
                       start_control = 1; // Reiniciar el flag cuando Start se desactiva
                     end  
		end   
	endtask
	
	task monitor_output;
	    while (1) begin
	        @(mports.md);
	        if (mports.md.Done) begin
                    target_coc = cola_target_coc.pop_back();
                    target_res = cola_target_res.pop_back();
              	    observado_Coc = mports.md.Coc;
              	    observado_Res = mports.md.Res;
                    $display("|Sacamos ideal de la cola -------> Cociente: %11d, Residuo: %11d |", target_coc, target_res);
                    $display("|Valores a comparar: ideal_Coc:%11d, real_Coc:%11d               |", target_coc, observado_Coc);
	            $display("|Valores a comparar: ideal_Res:%11d, real_Res:%11d               |", target_res, observado_Res);
                    assert (observado_Coc == target_coc) else $error("Cociente incorrecto: Esperado %d, Observado %d", target_coc, observado_Coc);
                    assert (observado_Res == target_res) else $error("Residuo incorrecto: Esperado %d, Observado %d", target_res, observado_Res);
	        end
	    end
	endtask
	
    endclass


    class environment;

        virtual Interface_if.test testar_ports;
        virtual Interface_if.monitor monitorizar_ports;

	// Covergroup para valores de Num	
	covergroup valores_num @(monitorizar_ports.md);

	  zero: coverpoint monitorizar_ports.md.Num {
	     bins zero[] = {0}; }

	  rango_100: coverpoint monitorizar_ports.md.Num {
	     bins range_100[] = {[-100:100]}; }

	  rango_100_a_1K: coverpoint monitorizar_ports.md.Num {
	     bins range_100_to_1K[] = {[101:1000]}; }

	  rango_neg_100_a_neg_1K: coverpoint monitorizar_ports.md.Num {
	     bins range_neg_100_to_neg_1K[] = {[-1000:-101]}; }

	  rango_1K_a_10K: coverpoint monitorizar_ports.md.Num {
	     bins range_1K_to_10K[] = {[1001:10000]}; }

	  rango_10K_a_100K: coverpoint monitorizar_ports.md.Num {
	     bins range_10K_to_100K[] = {[10001:100000]}; }

	  rango_100K_a_1M: coverpoint monitorizar_ports.md.Num {
	     bins range_100K_to_1M[] = {[100001:1000000]};}

	  rango_neg_1K_a_neg_1M: coverpoint monitorizar_ports.md.Num {
	     bins range_neg_1K_to_neg_1M[] = {[-1000000:-1001]}; }
	endgroup

	// Covergroup para valores de Den
	covergroup valores_den @(monitorizar_ports.md);
	
	  zero: coverpoint monitorizar_ports.md.Den {
	     illegal_bins zero = {0}; 
	     bins default_bin = default;      // Agrupa todos los otros valores en un único bin
	   }

	  rango_100: coverpoint monitorizar_ports.md.Den {
	     bins range_100[] = {[-100:100]}; }

	  rango_100_a_1K: coverpoint monitorizar_ports.md.Den {
	     bins range_100_to_1K[] = {[101:1000]}; }

	  rango_neg_100_a_neg_1K: coverpoint monitorizar_ports.md.Den {
	     bins range_neg_100_to_neg_1K[] = {[-1000:-101]}; }

	  rango_1K_a_10K: coverpoint monitorizar_ports.md.Den {
	     bins range_1K_to_10K[] = {[1001:10000]}; }

	  rango_10K_a_100K: coverpoint monitorizar_ports.md.Den {
	     bins range_10K_to_100K[] = {[10001:100000]}; }

	  rango_100K_a_1M: coverpoint monitorizar_ports.md.Den {
	     bins range_100K_to_1M[] = {[100001:1000000]};}

	  rango_neg_1K_a_neg_1M: coverpoint monitorizar_ports.md.Den {
	     bins range_neg_1K_to_neg_1M[] = {[-1000000:-1001]}; }
	endgroup


	//declaraciones de objetos
        Scoreboard sb;
        RCSG busInst;


        function new(virtual Interface_if.test ports, virtual Interface_if.monitor mports);
            begin
	    testar_ports = ports;
            monitorizar_ports = mports;

	    //instanciación objetos
	    busInst = new;               //construimos la clase de valores random
            sb = new(monitorizar_ports); //construimos el scoreboard      
   	    valores_num = new();             // Instancia del covergroup
	    valores_den = new();             // Instancia del covergroup
	    end
        endfunction

        task muestrear;
            fork
                sb.monitor_input;
                sb.monitor_output;
            join_none
        endtask

	task prueba_combinaciones;
	    int num[4] = {100, 100, -200, -200}; // Valores de prueba para el Numerador
	    int den[4] = { 50, -50,  150, -150};   // Valores de prueba para el Denominador
 	    string sign_num;
   	    string sign_den;
	    $display("+------------------------------------------------------------------------------+");
  	    $display("|                          Pruebas combinacionales                             |");
 	    $display("+------------------------------------------------------------------------------+");
	    for (int i = 0; i < 4; i++) begin
	        testar_ports.sd.Num <= num[i];
	        testar_ports.sd.Den <= den[i];

           	sign_num = (num[i] > 0) ? "Pos" : "Neg";
	   	sign_den = (den[i] > 0) ? "Pos" : "Neg";	
		$display("|                                                                              |");
	        $display("|Combinacion %s/%s:     Num =%11d, Den =%11d                   |",
	                 sign_num, sign_den, testar_ports.sd.Num, testar_ports.sd.Den);
	
	        // Inicia la operación
	        @(testar_ports.sd);
	        testar_ports.sd.Start <= 1'b1;
	        @(testar_ports.sd);
	        #10 testar_ports.sd.Start <= 1'b0;
	
	        // Espera a que la operación termine
	        @(negedge testar_ports.sd.Done);
		$display("|Resultado:       Coc =%11d, Res =%11d                           |",monitorizar_ports.md.Coc, monitorizar_ports.md.Res);
	

	    end
	    $display("+------------------------------------------------------------------------------+");
	endtask

        task prueba_random;
   	 int max_iteraciones = 100000; // Define un límite
   	 int iteraciones = 0;
	 $display("                                                                       ");
         $display("+------------------------------------------------------------------------------+");
  	 $display("|                                Pruebas random                                |");
 	 $display("+------------------------------------------------------------------------------+");
           while (iteraciones < max_iteraciones) begin
//	   while (valores_num.get_coverage()<50) begin
                assert (busInst.randomize()) else $fatal("Randomization failed in iteration %d", iteraciones);
		// Llama a post_randomize después de la aleatorización
       		
		$display("|                                                                              |");
		$display("|Generamos numeros aleatorios ---> Num_rand:%11d,  Den_rand:%11d |", busInst.num_rand, busInst.den_rand);
                testar_ports.sd.Num <= busInst.num_rand;
                testar_ports.sd.Den <= busInst.den_rand;

                valores_num.sample();                  // Muestreo para la cobertura    
                valores_den.sample();                  // Muestreo para la cobertura    

		@(testar_ports.sd);
   		testar_ports.sd.Start <= 1'b1;     // Activa `Start` 
		@(testar_ports.sd);
    		#10 testar_ports.sd.Start <= 1'b0; // Baja `Start` para indicar solo un pulso

                @(negedge testar_ports.sd.Done);
		iteraciones++;
		$display("|iteracion: %d",  iteraciones);  
            end
  
        endtask

    endclass

endpackage

// Programa para la instanciación de módulos//////////////////////////////////////////////////////////////////////////////
program estimulos #(parameter tamanyo = 32) (Interface_if.test testar, Interface_if.monitor monitorizar);
    utilidades_verificacion::environment casos = new(testar, monitorizar);
   
    initial begin
	$display("+------------------------------------------------------------------------------+");
        $display("|                             Iniciando pruebas...                             |");
	$display("+------------------------------------------------------------------------------+");
	$display("                                                                                ");
	casos.muestrear;
	casos.prueba_combinaciones;
        casos.prueba_random;
	$display("+------------------------------------------------------------------------------+");
	$display("|                               Pruebas acabadas                               |");
	$display("+------------------------------------------------------------------------------+");
         $stop;
    end
endprogram
