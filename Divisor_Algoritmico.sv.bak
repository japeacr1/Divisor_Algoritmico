module Divisor_Algoritmico //pruebas


#(parameter tamanyo=32)
(input CLK,
input RSTa,
input Start,
input logic [tamanyo-1:0] Num,
input logic [tamanyo-1:0] Den,

output logic [tamanyo-1:0] Coc,
output logic [tamanyo-1:0] Res,
output Done);





logic signed [tamanyo-1:0] Coc_temp;
logic signed [tamanyo-1:0] Res_temp;
logic signed [tamanyo-1:0] Coc_temp2;
logic signed [tamanyo-1:0] Res_temp2;
logic signed [tamanyo-1:0] Num_temp;
logic signed [tamanyo-1:0] Den_temp;
logic [2*tamanyo+1:0] END_MULT_aux;
logic [2*tamanyo+1:0] [tamanyo-1:0] Coc_aux;
logic [2*tamanyo+1:0] [tamanyo-1:0] Res_aux;

assign Coc_temp=$signed(Num)/$signed(Den);
assign Res_temp=$signed(Num)%$signed(Den);
always_ff @(posedge CLK, negedge RSTa)
if (!RSTa)
  begin
  END_MULT_aux<='0;
    Coc_aux<='0;
    Res_aux<='0;
  end
else 
    begin
      END_MULT_aux<={Start, END_MULT_aux[2*tamanyo+1:1]};
      Coc_temp2=Start?(Coc_temp):'0;
      Res_temp2=Start?(Res_temp):'0;
      Coc_aux<={Coc_temp2, Coc_aux[2*tamanyo+1:1]};
      Res_aux<={Res_temp2, Res_aux[2*tamanyo+1:1]};
    end



assign  Done=END_MULT_aux[0];
assign  Coc=Coc_aux[0];
assign  Res=Res_aux[0];

endmodule

//module Divisor_Algoritmico
// 
//
//#(parameter tamanyo=32)           
//(input CLK,
//input RSTa,
//input Start,
//input logic [tamanyo-1:0] Num,
//input logic [tamanyo-1:0] Den,
//
//output logic [tamanyo-1:0] Coc,
//output logic [tamanyo-1:0] Res,
//output Done);
//
//logic [tamanyo-1:0] CONT;
//logic [tamanyo-1:0] ACCU;
//logic [tamanyo-1:0] M;
//logic [tamanyo-1:0] Q;
//logic [tamanyo-1:0] SignNum;
//logic [tamanyo-1:0] SignDen;
//logic fin;
////vuestro cÃ³digo
//
//	reg [1:0] state;
//	parameter D0=0, D1=1, D2=2, D3=3;
//		
//		always_ff @(posedge CLK or negedge RSTa) begin
//        if (!RSTa) 
//				begin
//            state <= D0;
//            ACCU <= 0;
//            Q <= 0;
//            CONT <= 0;
//            fin <= 0;
//            Coc <= 0;
//            Res <= 0;
//				end 
//			else 
//            case (state)
//                D0: begin
//                    fin <= 0;
//                    if (Start) begin
//                        ACCU <= 0;
//                        CONT <= tamanyo - 1;
//                        SignNum <= Num[tamanyo - 1];
//                        SignDen <= Den[tamanyo - 1];
//                        Q <= (Num[tamanyo - 1] ? ~Num + 1 : Num); 
//                        M <= (Den[tamanyo - 1] ? ~Den + 1 : Den); 
//                        state <= D1;
//							   end
//							end
//
//                D1: begin
//                    {ACCU,Q} <= {ACCU[tamanyo-2:0], Q, 1'b0};
//                    state <= D2;
//						  end
//                
//                D2: begin
//                    CONT <= CONT - 1;
//                    if (ACCU >= M) begin
//                        Q <= Q + 1;
//                        ACCU <= ACCU - M;
//                    end
//                    if (CONT == 0) 
//                        state <= D3;
//                    else 
//                        state <= D1;
//						  end
//
//                D3: begin
//                    fin <= 1;
//                    Coc <= (SignNum ^ SignDen) ? (~Q + 1) : Q;
//                    Res <= (SignNum) ? (~ACCU + 1) : ACCU;
//                    state <= D0; 
//						  end
//
//                default: state <= D0;
//            endcase
//			end
//assign Done = fin;
//endmodule




		